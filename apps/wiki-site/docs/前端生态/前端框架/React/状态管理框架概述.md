# 状态管理框架概述


> [原文指向](https://zhuanlan.zhihu.com/p/53599723)

概述内容涉及: Vuex、Flux、Redux、Redux-saga、Dva、MobX

在使用前端框架进行开发的时候, 无论是 vue 还是 react, 都需要管理状态. 主流的状态管理的解决思路就是把组件之间的状态抽取出来(隔离变化), 遵循特定的约定(约定优于配置), 统一管理, 便于预测和管理变化.

## Store

把状态保存到一个外部变量是最简单和朴素的思想. 比如使用一个全局变量来保存我们的数据.

但是这样有一个不利于追踪变更的问题, 因此稍微将这个变量复杂为一个对象, 就是一个简单的 Store 模式:

```js
var store = {
    state: {
        message: 'Hello!'
    },
    setMessageAction(newValue) {
        // 发生改变记录点日志啥的
        this.state.message = newValue;
    },
    clearMessageAction() {
        this.state.message = '';
    }
};
```

store 的 state 存储数据, action 来控制 state 的改变, 通过 action 来形成操作日志.

因为依赖于 action 来记录数据的变化, 我们必须限制禁止通过 action 外的代码对 store 进行操作. 也就是说: 组件必须通过 action 来改变 state, action 分发(dispatch)事件来通知 store 发生变化. 这样的约定就能记录所有 store 中发生的 state 改变, 同时实时记录变更(mutation), 保存状态快照, 历时回滚/时光旅行.

这样一个简单的 Flux 就构建出来了

## Flux

Flux 的本质是一种设计思想. 他吧一个引用分为: View, Action, Dispatch, Store 4 个部分.

-   View: 展示数据和反应变化
-   Store: 存储数据
-   Action/Dispatch: View 通过 Action 告诉 dispatch, 由 dispatch 转发给 Store 改变数据.

Flux 有一些特点:

-   Distpatch 接受所有的 Action, 然后发给所有的 Store
-   Action 可以是 View 触发的, 也可以是其他的例如测试用例触发的.
-   Dispatch 转发也是给所有的 Store
-   Store 的改变只能通过 Action, 所以 Store 不能有公开的 Setter, 只能有公开的 Getter.

其中, 最大的特点是数据的单向流动.

## Redux

Flux 与 Redux 的思想有类似的地方也有不同的地方. 其一是 Store 只有一个, 其二是使用 Reducer 而不是 Action.

### Store

Redux 只有一个唯一的 Store, Store 中的 State 不能直接修改, 每次只能返回一个新的 State. Redux 用`createStore`来生成 Store:

```js
import { createStore } from 'redux';
const store = createStore(fn);
```

store 通过 store.subscribute 方法设置监听函数, 一旦 state 发生变化, 就自动执行该函数. 在 React 中,吧组件的 render 方法或者 setState 方法订阅进去就能听实现自动更新 View 了.

### Action

Acion 是 View 发出的对 Store State 产生变化的通知. 有一个 Type 属性, 代表 Action 的名称, 其他属性作为 State 更变参考:

```js
const action = {
    type: 'ADD_TODO',
    payload: 'Learn Redux'
};
```

### Reducer

Redux 没有 Dispatcher 的概念, Store 中继承了 dispatch 方法, store.dispatch()是 View 发出 Action 的唯一方法.

```js
import { createStore } from 'redux';
const store = createStore(fn);

store.dispatch({
    type: 'ADD_TODO',
    payload: 'Learn Redux'
});
```

redux 中的 Reducer 是一个纯函数, Store 收到 Action 以后, 必须给出一个新的 State, 这样 View 才会发生变化, 这种 State 的计算过程就叫做 Reducer.

> Reducer 是一个函数式编程的概念, map 是映射, reduce 就是归纳. 映射是将一个列表映射成另一个列表, reduce 是把一个列表通过一定的规则进行合并, 返回一个 newValue.

下面的代码声明了 reducer:

```js
const defaultState = 0;
const reducer = (state = defaultState, action) => {
    switch (action.type) {
        case 'ADD':
            return state + action.payload;
        default:
            return state;
    }
};
```

createrStore 接受 Reducer 作为参数, 生成一个新的 Store, 以后每当 store.dispatch 发送一个新的 Action, 就会自动调用 Reducer, 得到新的 State.

```js
import { createStore } from 'redux';
const store = createStore(reducer);
```

cretaeStore 的把内部大概实现如下:

```js
const createStore = reducer => {
    let state;
    let listeners = [];

    const getState = () => state;

    const dispatch = action => {
        state = reducer(state, action);
        listeners.forEach(listener => listener());
    };

    const subscribe = listener => {
        listeners.push(listener);
        return () => {
            listeners = listeners.filter(l => l !== listener);
        };
    };

    dispatch({});

    return { getState, dispatch, subscribe };
};
```

Redux 有很多的 Reducer, 对于大型应用来说, State 会十分庞大, 导致 Reducer 函数也十分庞大, 所以需要拆分, Redux 里每一个 Reducer 负责维护 State 树中的一部分数据, 多个 Reducer 通过 combineReducers 方法合成一个根 Reducer, 这个 Reducer 委会整个 State

```js
import { combineReducers } from 'redux';

// 注意这种简写形式，State 的属性名必须与子 Reducer 同名
const chatReducer = combineReducers({
    Reducer1,
    Reducer2,
    Reducer3
});
```

combineReducer 基本的实现大概如下:

```js
const combineReducers = reducers => {
    return (state = {}, action) => {
        return Object.keys(reducers).reduce((nextState, key) => {
            nextState[key] = reducers[key](state[key], action);
            return nextState;
        }, {});
    };
};
```

Redux 的流程大致如下:

1. 用户通过 view 发出 Action

    ```js
    store.dispatch(action);
    ```

2. Store 自动调用 Reducer, 并且传入两个参数: 当前 State 和收到 Action. Reducer 返回新的 State:

    ```js
    let nextState = xxxReducer(previousState, action);
    ```

3. State 发生变化, Store 调用监听函数:

    ```js
    store.subscribe(listener);
    ```

4. listerner 通过 store.getState()得到当前状态, 触发重新渲染:

    ```js
    function listerner() {
        let newState = store.getState();
        component.setState(newState);
    }
    ```

对比 Flux 最大的不同, 就在于 Redux 中的变化都会经过 Reducer 根的整合.

简单来说, Redux 有三大原则: 单一数据源, State 只读, 使用纯函数来执行修改.

同样的 Redux 和 Flux 一样是单项数据流.

### 中间件

在实际项目中, 处理同步操作, 还会有异步操作.

在 Redux 中, 同步是 Action 发出以后, Reducer 立即计算 State. 异步的表现就是 Action 发出一段时间后执行 Reducer.

为了在一步操作后自动执行 Reducer, Redux 引入了中间件 Middleware 的概念.

但是 Redux 的每一步都比较纯粹, Reducer 是一个纯函数, Action 是一个纯对象. 所以只能在 View 里发送 Action 的时候进行异步操作了, 比如下面这个例子:

```js
let next = store.dispatch;
store.dispatch = function dispatchAndLog(action) {
    console.log('dispatching', action);
    next(action);
    console.log('next state', store.getState());
};
```

所以中间件简单来说, 就是对 store.dispatch 方法进行一些改造的函数.

Redux 提供了一个 applyMiddleware 方法来应用中间件:

```js
const store = createStore(reducer, applyMiddleware(thunk, promise, logger));
```

这个方法主要就是把所有中间件组成一个数组, 依次执行. 也就是说, 任何被发送到 store 的 action 都会经过 thunk,promise, logger 这几个中间件了.

### 处理异步

异步操作需要关心两个时间点:

1. 请求开始: 触发 State 更新为 pending
2. 请求结束: 获取结果,成功或者失败

#### redux-thunk

thunk 比较简单:

```js
const createFetchDataAction = function(id) {
    return function(dispatch, getState) {
        // 开始请求，dispatch 一个 FETCH_DATA_START action
        dispatch({
            type: FETCH_DATA_START,
            payload: id
        });
        api.fetchData(id)
            .then(response => {
                // 请求成功，dispatch 一个 FETCH_DATA_SUCCESS action
                dispatch({
                    type: FETCH_DATA_SUCCESS,
                    payload: response
                });
            })
            .catch(error => {
                // 请求失败，dispatch 一个 FETCH_DATA_FAILED action
                dispatch({
                    type: FETCH_DATA_FAILED,
                    payload: error
                });
            });
    };
};

//reducer
const reducer = function(oldState, action) {
    switch (action.type) {
        case FETCH_DATA_START:
        // 处理 loading 等
        case FETCH_DATA_SUCCESS:
        // 更新 store 等
        case FETCH_DATA_FAILED:
        // 提示异常
    }
};
```

#### redux-promise

与 redux-thunk 相似, 但是做了一些简化, 成功失败手动 dispatch 被封装成自动了:

```js
const FETCH_DATA = 'FETCH_DATA';
//action creator
const getData = function(id) {
    return {
        type: FETCH_DATA,
        payload: api.fetchData(id) // 直接将 promise 作为 payload
    };
};
//reducer
const reducer = function(oldState, action) {
    switch (action.type) {
        case FETCH_DATA:
            if (action.status === 'success') {
                // 更新 store 等处理
            } else {
                // 提示异常
            }
    }
};
```

## Vuex

![](/img/TIM截图20190407131436.png)

Vuex 主要用于 Vue, 和 Flux, Redux 的思想类似.

### Store

每一个 Vuex 中有一个保存着全局共享的状态数据的 Store State. State 是单一的, 一个应用仅会包含一个 Store 实例.

Vuex 通过 store 选项把 state 注入程序, 子组件通过`this.$store`访问 store:

```js
const app = new Vue({
    el: '#app',
    // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件
    store,
    components: { Counter },
    template: `
    <div class="app">
      <counter></counter>
    </div>
  `
});
const Counter = {
    template: `<div>{{ count }}</div>`,
    computed: {
        count() {
            return this.$store.state.count;
        }
    }
};
```

### Mutation

State 通过 mutation 进行改变. 每个 mutation 都有一个字符串的 **事件类型(type)** 和一个 **回调函数(handler)**

```js
const store = new Vuex.Store({
    state: {
        count: 1
    },
    mutations: {
        increment(state) {
            // 变更状态
            state.count++;
        }
    }
});
```

触发 mutation 事件只能通过`store.commit`:

```js
store.commit('increment');
```

mutation 类似 Reducer, 但是 Vuex 支持直接修改 State, 类似 Flux, 不需要每次都搞一个新的 State.

### Action

mutation 必须是同步的. 对比与 Redux 的中间件, Vuex 加入了 Action 来处理异步, 把同步和异步拆分. View 通过`store.dispatch('increment')`来触发某个 Action, Action 中执行异步操作, 然后通过`store.commit('increment')`来触发 mutation, 一个 action 一个触发多个 mutation, 所以 vuex 的 action 类似于一个灵活好用的中间件.

Vuex 的这种拆分不是唯一和必须的, 我们也可以直接在应用内部异步请求, 再直接 commit mutation.

Vuex 还引入了 Getter, 方便计算属性的复用

Vuex 的单一状态树可以把 State 进行拆分, 最后组合. Vuex 引入 Module, 每个 Module 有自己的 state, mutation, action, getter.

## React-redux

Redux 与 React 没有关系, 两者因为单向数据流的关系搭配使用比较简单. 所以 React 一般都用 Redux 进行状态管理. 并且使用 react-redux 来配合使用.

这个库把 React 组件分成容器组件和展示组件, 容器组件通过 connenct 生成, 订阅全局状态的变化, 通过`mapStateToProps`对全局状态进行过滤, 展示型组件不从 state 获取数据, 数据来自父组件.

![](/img/442139485-5c18ded76d911_articlex.png)

简单的来说,react-redux 就是多了个 connect 方法连接容器组件和 UI 组件, 把容器的 state 映射到 UI 组件的 props 中.

## React-saga

redux-saga 也是处理 redux 的异步的库, 但是采用了另一种思路. 它没有把异步操作放在 action creator 中, 也没有处理 reductor, 而是把所有的异步操作看做"线程", 可以通过普通的 action 触发, 当操作完成时也会触发 action 作为输出. saga 本意一连串的事件.

redux-saga 的目标是把异步的副作用管理好, 其中使用 Generator 这个 ES6 的语法.

Generator 的代码可以被延缓执行, 具备暂停和记忆的功能. saga 可以想象成一个以最快速度不断的调用 next 方法并尝试获取所有 yield 表法师值的线程.

```js
// saga.js
import { take, put } from 'redux-saga/effects';

function* mySaga() {
    // 阻塞: take方法就是等待 USER_INTERACTED_WITH_UI_ACTION 这个 action 执行
    yield take(USER_INTERACTED_WITH_UI_ACTION);
    // 阻塞: put方法将同步发起一个 action
    yield put(SHOW_LOADING_ACTION, { isLoading: true });
    // 阻塞: 将等待 FetchFn 结束，等待返回的 Promise
    const data = yield call(FetchFn, 'https://my.server.com/getdata');
    // 阻塞: 将同步发起 action (使用刚才返回的 Promise.then)
    yield put(SHOW_DATA_ACTION, { data: data });
}
```

简单来理解, 每个 yield 都发起了阻塞, saga 会等待执行返回结果再执行下一指令, 相当于 take/put/call 这几个方法的调用变成了同步的, 上面的全部反悔了才会执行下面的, 类似于 await.

使用 saga 可以控制副作用操作的细粒度, 把异步操作和同步操作随意的组合使用. 再配合上`takeEvery`, `takeLastest`之类的辅助函数, 来控制是否允许多个异步请求同时执行.

```js
// 并行执行，并等待所有的结果，类似 Promise.all 的行为
const [users, repos] = yield [
  call(fetch, '/users'),
  call(fetch, '/repos')
]

// 并行执行，哪个先完成返回哪个，剩下的就取消掉了
const {posts, timeout} = yield race({
  posts: call(fetchApi, '/posts'),
  timeout: call(delay, 1000)
})
```

与 redux-thunk 等其他异步中间件进行对比, redux-saga 主要有下面几个特点:

-   异步数据获取的相关业务逻辑放在了单独的 saga.js 中, 不在掺杂在 action.js 或者 component.js 中.
-   dispatch 的参数是标准的 action，没有魔法。
-   saga 代码采用类似同步的方式书写，代码变得更易读。
-   代码异常/请求失败 都可以直接通过 try/catch 语法直接捕获处理。
-   很容易测试，如果是 thunk 的 Promise，测试的话就需要不停的 mock 不同的数据。

## Dva

dva 是基于 redux 和 redux-saga 的数据流方案, 额外内置了 react-router 和 fetch, 可以理解为一个轻量级的应用框架.

```js
app.model({
    // namespace - 对应 reducer 在 combine 到 rootReducer 时的 key 值
    namespace: 'products',
    // state - 对应 reducer 的 initialState
    state: {
        list: [],
        loading: false
    },
    // subscription - 在 dom ready 后执行
    subscriptions: [
        function(dispatch) {
            dispatch({ type: 'products/query' });
        }
    ],
    // effects - 对应 saga，并简化了使用
    effects: {
        ['products/query']: function*() {
            yield call(delay(800));
            yield put({
                type: 'products/query/success',
                payload: ['ant-tool', 'roof']
            });
        }
    },
    // reducers - 就是传统的 reducers
    reducers: {
        ['products/query'](state) {
            return { ...state, loading: true };
        },
        ['products/query/success'](state, { payload }) {
            return { ...state, loading: false, list: payload };
        }
    }
});
```

原本的书写方式是创建 sagas/products.js, reducers/products.js 和 actiosn/productes.js, 然后把 saga,action,reducer 分开来写, 来回切换, 现在就全都写在一起了.

![](/img/TIM截图20190407160007.png)

使用 redux+redux-saga 来表示结构如上图所示, saga 拦截 add 这个 action, 发起 http 请求, 如果请求成功, 则继续想 reducer 发起一个 addTodoSccess 的 action, 提示创建成功, 反之则发送 addToDoFail 的 action 即可.

如果使用 Dva, 则结构如下所示:

![](/img/art20190123_141244_FIKICX.jpg)

主要是吧 store 和 saga 统一为 model, 增加一个 Subscriptions, 用于收集其他来源的 action, 比如快捷键操作.

## MobX

MobX 不能算 Flux 体系的, 状态管理本质上是解决应用状态管理的问题, MobX 是除了 Flux 体系的另一个选项.

MobX 的思想简单来说就是状态发生变化, 所有用到状态的代码就自动发生变化.

![](/img/flow.png)

如果说 FLux 是函数式编程思路下的状态管理, MobX 就更像是面向对象编程下的, 它把 state 包装成可观察的对象, 对象驱动各种变化.

```js
const obj = observable({
    a: 1,
    b: 2
});

autoRun(() => {
    console.log(obj.a);
});

obj.b = 3; // 什么都没有发生
obj.a = 2; // observe 函数的回调触发了，控制台输出：2
```

只要 obj.a 的属性发生变化, 所有使用的地方都会被调用, autoRun 会观察所有依赖 obj.a 的代码, 发生改变的时候就去触发所有依赖代码进行更新.

MobX 允许多个 store, 并且这些 store 里的 state 可以直接修改, 不用像 redux 每次返回一个新的. 自由度高, 代码少. 另一方面是维护难度提升了.

MobX 和 Flux, Redux 一样, 无管框架, 可以用于 React 或者 Vue.

最后通过一个 DEMO 来比较 Redux 和 MobX 的区别:

![](/img/v2-d40d4dfcd279330c4ef49ef794f51f2f_b.gif)

Redux:

```js
import React, { Component } from 'react';
import { createStore, bindActionCreators } from 'redux';
import { Provider, connect } from 'react-redux';

// ①action types
const COUNTER_ADD = 'counter_add';
const COUNTER_DEC = 'counter_dec';

const initialState = { a: 0 };
// ②reducers
function reducers(state = initialState, action) {
    switch (action.type) {
        case COUNTER_ADD:
            return { ...state, a: state.a + 1 };
        case COUNTER_DEC:
            return { ...state, a: state.a - 1 };
        default:
            return state;
    }
}

// ③action creator
const incA = () => ({ type: COUNTER_ADD });
const decA = () => ({ type: COUNTER_DEC });
const Actions = { incA, decA };

class Demo extends Component {
    render() {
        const { store, actions } = this.props;
        return (
            <div>
                <p>a = {store.a}</p>
                <p>
                    <button className="ui-btn" onClick={actions.incA}>
                        增加 a
                    </button>
                    <button className="ui-btn" onClick={actions.decA}>
                        减少 a
                    </button>
                </p>
            </div>
        );
    }
}

// ④将state、actions 映射到组件 props
const mapStateToProps = state => ({ store: state });
const mapDispatchToProps = dispatch => ({
    // ⑤bindActionCreators 简化 dispatch
    actions: bindActionCreators(Actions, dispatch)
});
// ⑥connect产生容器组件
const Root = connect(
    mapStateToProps,
    mapDispatchToProps
)(Demo);

const store = createStore(reducers);
export default class App extends Component {
    render() {
        return (
            <Provider store={store}>
                <Root />
            </Provider>
        );
    }
}
```

MobX:

```js
import React, { Component } from 'react';
import { observable, action } from 'mobx';
import { Provider, observer, inject } from 'mobx-react';

// 定义数据结构
class Store {
    // ① 使用 observable decorator
    @observable a = 0;
}

// 定义对数据的操作
class Actions {
    constructor({ store }) {
        this.store = store;
    }
    // ② 使用 action decorator
    @action
    incA = () => {
        this.store.a++;
    };
    @action
    decA = () => {
        this.store.a--;
    };
}

// ③实例化单一数据源
const store = new Store();
// ④实例化 actions，并且和 store 进行关联
const actions = new Actions({ store });

// inject 向业务组件注入 store，actions，和 Provider 配合使用
// ⑤ 使用 inject decorator 和 observer decorator
@inject('store', 'actions')
@observer
class Demo extends Component {
    render() {
        const { store, actions } = this.props;
        return (
            <div>
                <p>a = {store.a}</p>
                <p>
                    <button className="ui-btn" onClick={actions.incA}>
                        增加 a
                    </button>
                    <button className="ui-btn" onClick={actions.decA}>
                        减少 a
                    </button>
                </p>
            </div>
        );
    }
}

class App extends Component {
    render() {
        // ⑥使用Provider 在被 inject 的子组件里，可以通过 props.store props.actions 访问
        return (
            <Provider store={store} actions={actions}>
                <Demo />
            </Provider>
        );
    }
}

export default App;
```
