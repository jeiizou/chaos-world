# 语法特性-Decorators

## Decorator的历史

- 2014年4月10日, Decorators在TC39上呗提出. 这个提案被添加到TC39的stage0阶段
- 2014年10月22日, Angular团队宣布Angular2.0会使用AtScript并且编译到js和Dart. 他们计划在AtScript中支持:
  - 三种类型注释:
    - 类型注释
    - 字段树注释显式声明
    - 元数据注释, 具有和装饰器相同的语法, 但是只添加元数据, 不改带注释的构造的工作方式
  - 运行时的类型检查
  - type introspection: 类型内省
- 2015年1月28日, angular和ts团队交换了一些想法, 3月5日, angular和ts团队宣布angular从AtScript直接切换到使用TpeScript, Typescript会支持一些AtScript的特性(尤其是装饰器的部分)
- 2015年3月24日, decorator 提案被推进到stage1,
- 2015年7月20日, ts1.5发布, 并且支持使用`experimentalDecorators`开启stage1下的装饰器越发
- 2016年7月28日, decorator 被推进到stage2.
- 2022年3月28日, decorator 被推进到stage3.

## 什么是 Decorators

`Decorators`可以让我们改变使用js的构造函数(class或者其成员方法), 比如:

```js
class C {
  @trace
  toString() {
    return 'C';
  }
}
```

实现`trace`只需要写一个函数:

```js
function trace(decoratedMethod) {
  // Returns a function that replaces `decoratedMethod`.
}
```

上面的class C等价于:

```js
class C {
  toString() {
    return 'C';
  }
}
C.prototype.toString = trace(C.prototype.toString);
```

换句话说, 一个Decorators就是一个能够用来当一个构造器的函数.

编写和使用Decorators是元编程的一种:

- 我们不写直接处理数据的代码(编程)
- 我们写的代码会用于处理用户代码(元编程)

### Decorator Function

装饰器函数在TS的中类型声明大概是这样的:

```js
type Decorator = (
  value: DecoratedValue, // only fields differ
  context: {
    kind: string;
    name: string | symbol;
    addInitializer(initializer: () => void): void;

    // Don’t always exist:
    static: boolean;
    private: boolean;
    access: {get: () => unknown, set: (value: unknown) => void};
  }
) => void | ReplacementValue; // only fields differ
```

一个装饰器函数, 一般来说是一个函数

- value: 装饰器装饰的函数(类或成员)
- context对象:
  - 附加的value的信息
  - 一个简单的api, 用于进行元编程

`kind`属性告诉装饰器是用在哪个JS构造器上, 这样我们可以用同样的装饰器来应用到多个目标的构造器.

当前来说, 双时期可以用在:

- class
- method
- getter
- setter
- accessor(一个新的类成员, 稍后介绍)
- filed

其类型:

```ts
type Decorator =
  | ClassDecorator
  | ClassMethodDecorator
  | ClassGetterDecorator
  | ClassSetterDecorator
  | ClassAutoAccessorDecorator
  | ClassFieldDecorator
;
```

## 装饰器的作用

每个装饰器都可以有四个方面的作用:

- 它可以通过更改参数值来更改修饰的实体。
- 它可以通过返回兼容的值来替换修饰的实体.
  - `Compatible`, 装饰器必须返回相同类型的值, 比如class的装饰器必须返回一个可构造的值
  - 如果装饰器不想替换装饰值，它可以通过不返回任何内容来显式或隐式返回 `undefined`
- 向其他人展示对装饰实体的访问权限。上下文`access`使它能够通过其方法`.get()`和`.set()`实现这一点。
- 处理修饰实体及其容器（如果它有一个），在两者都存在之后：该功能由context.addInitializer提供。它允许装饰器注册一个初始值设定项——一个在一切就绪时调用的回调（稍后将解释更多细节）。

### 能力1: 替换装饰实体

举例:

```js
function replaceMethod() {
  return function () { // (A)
    return `How are you, ${this.name}?`;
  }
}

class Person {
  constructor(name) {
    this.name = name;
  }
  @replaceMethod
  hello() { // (B)
    return `Hi ${this.name}!`;
  }
}

const robin = new Person('Robin');
assert.equal(
  robin.hello(), 'How are you, Robin?'
);
```

在这个例子中, 装饰器`@replaceMethod`把`hello`方法替成了自己返回的函数.

### 能力2: 向其他人公开对装饰实体的访问

```js
let acc;
function exposeAccess(_value, {access}) {
  acc = access;
}

class Color {
  @exposeAccess
  name = 'green'
}

const green = new Color();
assert.equal(
  green.name, 'green'
);
// Using `acc` to get and set `green.name`
assert.equal(
  acc.get.call(green), 'green'
);
acc.set.call(green, 'red');
assert.equal(
  green.name, 'red'
);
```

装饰将一个对象存储在变量ace中, 该变量允许我们访问`green`的实例属性`color`

### 能力3: 处理装饰实体及其容器

```js
function collect(_value, {name, addInitializer}) {
  addInitializer(function () { // (A)
    if (!this.collectedMethodKeys) {
      this.collectedMethodKeys = new Set();
    }
    this.collectedMethodKeys.add(name);
  });
}

class C {
  @collect
  toString() {}
  @collect
  [Symbol.iterator]() {}
}
const inst = new C();
assert.deepEqual(
  inst.collectedMethodKeys,
  new Set(['toString', Symbol.iterator])
);
```

初始化装饰器必须是普通函数(非箭头), 因为this需要访问隐式采纳数. 箭头函数不提供这种访问, 他们的this是静态作用域的.

### 汇总

| 装饰器类型    | (input) => output             | .access   |
| ------------- | ----------------------------- | --------- |
| Class         | (func) => func2               | –         |
| Method        | (func) => func2               | {get}     |
| Getter        | (func) => func2               | {get}     |
| Setter        | (func) => func2               | {set}     |
| Auto-accessor | ({get,set}) => {get,set,init} | {get,set} |
| Field         | () => (initValue)=>initValue2 | {get,set} |

其中每个函数中`this`的值如下:

| this is →                                | undefined | Class | Instance |
| ---------------------------------------- | --------- | ----- | -------- |
| Decorator               function         | ✔         |       |          |
| Static                  initializer      |           | ✔     |          |
| Non-static              initializer      |           |       | ✔        |
| Static field decorator  result           |           | ✔     |          |
| Non-static field        decorator result |           |       | ✔        |


## Decorators 的语法和语义

### 表达式语法

```
@(<<expr>>)
```

我们可以连续使用多个装饰器:

```js
@myFunc
@myFuncFactory('arg1', 'arg2')

@libraryModule.prop
@someObj.method(123)

@(wrap(dict['prop'])) // arbitrary expression

class MyClass {}
```

### 装饰器的执行顺序

- `@`评估: 在类定义的执行期间符号后的表达式, 以及计算的属性键和静态字段. 结果必须是一个函数, 他们存储在临时位置以便稍后调用
- `调用`: 装饰器函数在类定义的执行期间被调用, 在方法被评估之后, 构造函数和原型被组装之前. 其执行结果再次被存储在临时的位置
- `应用`: 调用所有装饰器函数后, 使用他们的结果, 影响构造函数和原型. 

```js
function decorate(str) {
  console.log(`EVALUATE @decorate(): ${str}`);
  return () => console.log(`APPLY @decorate(): ${str}`); // (A)
}
function log(str) {
  console.log(str);
  return str;
}

@decorate('class')
class TheClass {

  @decorate('static field')
  static staticField = log('static field value');

  @decorate('prototype method')
  [log('computed key')]() {}

  @decorate('instance field')
  instanceField = log('instance field value');
    // This initializer only runs if we instantiate the class
}

// Output:
// EVALUATE @decorate(): class
// EVALUATE @decorate(): static field
// EVALUATE @decorate(): prototype method
// computed key
// EVALUATE @decorate(): instance field
// APPLY @decorate(): prototype method
// APPLY @decorate(): static field
// APPLY @decorate(): instance field
// APPLY @decorate(): class
// static field value
```

### 装饰器初始化器运行的时机

- 类装饰器初始化器在类被完全定义并且所有静态字段都被初始化之后运行
- 非静态类元素的初始化器在实例化期间运行, 在实例字段被初始化之前
- 静态类元素装饰器的初始化器在类定义期间运行,在定义静态字段之前但在定义其他所有类元素之后


## 从装饰器中暴露数据

### 将暴露数据存储在周边范围内

比如:

```js
const classes = new Set(); // (A)

function collect(value, {kind, addInitializer}) {
  if (kind === 'class') {
    classes.add(value);
  }
}

@collect
class A {}
@collect
class B {}
@collect
class C {}

assert.deepEqual(
  classes, new Set([A, B, C])
);
```

### 通过工厂函数管理暴露的数据

```js
function createClassCollector() {
  const classes = new Set();
  function collect(value, {kind, addInitializer}) {
    if (kind === 'class') {
      classes.add(value);
    }
  }
  return {
    classes,
    collect,
  };
}

const {classes, collect} = createClassCollector();

@collect
class A {}
@collect
class B {}
@collect
class C {}

assert.deepEqual(
  classes, new Set([A, B, C])
);
```

### 通过类管理暴露的数据

```js
class ClassCollector {
  classes = new Set();
  install = (value, {kind}) => { // (A)
    if (kind === 'class') {
      this.classes.add(value); // (B)
    }
  };
}

const collector = new ClassCollector();

@collector.install
class A {}
@collector.install
class B {}
@collector.install
class C {}
```

## 类装饰器

```ts
type ClassDecorator = (
  value: Function,
  context: {
    kind: 'class';
    name: string | undefined;
    addInitializer(initializer: () => void): void;
  }
) => Function | void;
```

类装饰器的能力:

- 改变装饰类的值
- 通过返回可调用的值来替换装饰类
- 注册初始化器, 在装饰类完全设置后调用
- 得不到context.access, 因为累不是其他语言结构的成员(例如: 方法是类的成员)

### 例子: 收集实例

```js
class InstanceCollector {
  instances = new Set();
  install = (value, {kind}) => {
    if (kind === 'class') {
      const _this = this;
      return function (...args) { // (A)
        const inst = new value(...args); // (B)
        _this.instances.add(inst);
        return inst;
      };
    }
  };
}

const collector = new InstanceCollector();

@collector.install
class MyClass {}

const inst1 = new MyClass();
const inst2 = new MyClass();
const inst3 = new MyClass();

assert.deepEqual(
  collector.instances, new Set([inst1, inst2, inst3])
);
```

我们可以通过装饰器收集给定类的所有实例.

注意: 我们不能在`A`行返回箭头函数, 因为箭头函数不能被新调用. 他会破坏`instanceof`

